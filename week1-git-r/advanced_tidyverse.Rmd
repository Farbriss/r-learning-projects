---
title: "Advanced tidyverse Übungen"
author: "Fabrice Keller"
date: "`r Sys.Date()`"
output: pdf_document
---

Lernziele:

- Komplexe Datenmanipulationen mit dplyr
- Erweiterte Visualisierungen mit ggplot2
- Daten-Pivoting und String-Operationen
- Funktionale Programmierung Grundlagen


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Laden der nötigen Packages für diese Session
```{r}
library(tidyverse)       # Meta-Package: dplyr, ggplot2, tidyr, stringr etc.
library(palmerpenguins)  # Saubere Beispieldaten für Ökologie/Biologie
library(nycflights13)    # Flugdaten mit datetime, joins etc.
library(lubridate)       # Einfache Datums-/Zeitmanipulation
```
Überprüfe, welche Pakete geladen sind
```{r}
sessionInfo()
```

# Block 1: Fortgeschrittene dplyr-Operationen

## 1.1 Komplexe Mutate-Operationen

Konzept: `mutate()` erstellt neue Spalten basierend auf bestehenden Daten. Mit `case_when()` können wir komplexe bedingte Logik implementieren.

Dataset erkunden
```{r}
glimpse(penguins)  # Zeigt Datentypen und erste Werte
summary(penguins)  # Statistische Übersicht
```
Die ersten Zeilen anschauen
```{r}
head(penguins, 10)
```

Erweiterte mutate() Funktionen
mutate fügt zusätzliche Spalten an einen dataframe an
```{r}
penguins_advanced <- penguins %>%
  mutate(
    # CONDITIONAL LOGIC mit case_when()
    # Syntax: case_when(Bedingung ~ Ergebnis, TRUE ~ Default)
    size_category = case_when(
      body_mass_g < 3000 ~ "Small",      # Wenn Masse < 3000g
      body_mass_g < 4500 ~ "Medium",     # Sonst wenn < 4500g  
      body_mass_g < 6000 ~ "Large",      # Sonst wenn < 6000g
      TRUE ~ "Extra Large"               # Alle anderen Fälle
    ),
    
    # NUMERISCHE BERECHNUNGEN
    # Ratio-Berechnungen helfen, Proportionen zwischen Körperteilen zu verstehen
    bill_ratio = bill_length_mm / bill_depth_mm,
    flipper_body_ratio = flipper_length_mm / body_mass_g * 1000,  # *1000 für bessere Lesbarkeit
    
    # STRING-MANIPULATION
    # paste() verbindet Strings, str_sub() extrahiert Teilstrings
    species_island = paste(species, island, sep = "_"),
    species_short = str_sub(species, 1, 3),  # Erste 3 Buchstaben
    
    # STANDARDISIERUNG UND TRANSFORMATION
    body_mass_kg = body_mass_g / 1000,                    # Einheitenkonversion
    body_mass_scaled = as.vector(scale(body_mass_g)),     # Z-Score (Mittelwert=0, SD=1)
    
    # RANKING innerhalb von Gruppen (wird später nützlich)
    mass_rank = dense_rank(desc(body_mass_g))  # 1 = schwerster Pinguin
  )

# Schaue dir die neuen Spalten an
# mit select() kann man ein subset eines dataframes auswählen
penguins_advanced %>% 
  select(species, body_mass_g, size_category, bill_ratio, body_mass_scaled) %>%
  head(10)
```
WARUM das nützlich ist:

- size_category: Kategorisierung für Gruppierungen und Plots
- Ratios: Wichtig für allometrische Analysen in der Biologie
- Scaling: Nötig für Machine Learning und statistische Analysen

## 1.2 Fortgeschrittenes Grouping und Summarizing

### Gruppierte deskriptive Statistiken mit `group_by()` und `summarise()`

Die Kombination aus `group_by()` und `summarise()` ist das Herzstück der gruppierten Datenanalyse im tidyverse. Während `group_by()` den Datensatz in Untergruppen aufteilt (hier nach jeder Kombination aus Pinguinart und Insel), berechnet `summarise()` für jede dieser Gruppen separate statistische Kennzahlen und erzeugt dabei ein **neues, kompaktes Dataframe**. 

Im Gegensatz zu `mutate()`, das neue Spalten zum bestehenden Datensatz hinzufügt und alle ursprünglichen Zeilen beibehält, reduziert `summarise()` die Datenstruktur drastisch: Aus den ursprünglich 344 Pinguinbeobachtungen entstehen nur noch wenige Zeilen – eine pro Gruppe (Art-Insel-Kombination) – mit den berechneten Zusammenfassungen als neue Spalten.

Der Code berechnet zunächst grundlegende deskriptive Statistiken wie Mittelwerte, Mediane und Standardabweichungen für jede Gruppe. Besonders wichtig ist dabei der Parameter `na.rm = TRUE`, der fehlende Werte aus den Berechnungen ausschließt. Zusätzlich werden Quantile (25% und 75%) berechnet, die später für die Bestimmung des Interquartilsabstands verwendet werden und wichtige Informationen über die Verteilung der Daten liefern.

Die Anteilsberechnung `prop_female` zeigt eine clevere Anwendung logischer Operationen: `sum(sex == "female", na.rm = TRUE)` zählt alle TRUE-Werte (also alle Weibchen), während `sum(!is.na(sex))` die Anzahl aller Beobachtungen mit bekanntem Geschlecht ermittelt. Der Parameter `.groups = "drop"` am Ende des `summarise()`-Blocks ist wichtig, da er die Gruppierung wieder aufhebt und verhindert, dass nachfolgende Operationen unbeabsichtigt noch gruppiert ausgeführt werden.

Im anschließenden `mutate()`-Schritt werden aus den bereits berechneten Kennzahlen weitere aussagekräftige Variablen abgeleitet: Der Interquartilsabstand (`mass_range`) als Maß für die Streuung innerhalb jeder Gruppe, ein Variationskoeffizient zur relativen Einordnung der Variabilität und eine kategorische Einteilung der Stichprobengrößen. Das finale `arrange()` und `select()` sorgt für eine übersichtliche Darstellung der wichtigsten Ergebnisse, sortiert nach dem durchschnittlichen Körpergewicht der Gruppen.

Diese Analysestrategie ist fundamental für die explorative Datenanalyse, da sie systematische Unterschiede zwischen Subpopulationen aufdeckt und die Basis für weiterführende statistische Tests oder Visualisierungen bildet.

```{r}
# Gruppierte Statistik: Nach Art UND Insel zusammenfassen
penguin_stats <- penguins %>%
  group_by(species, island) %>%    # Gruppierung: Jede Kombination aus Art & Insel ist eine Gruppe
  summarise(
    # Basisstatistiken
    count = n(),                        # Anzahl Beobachtungen in der Gruppe
    mean_body_mass = mean(body_mass_g, na.rm = TRUE),    # Durchschnittliches Körpergewicht (ignoriert NA)
    median_flipper = median(flipper_length_mm, na.rm = TRUE), # Median Flossenlänge (ignoriert NA)
    sd_bill_length = sd(bill_length_mm, na.rm = TRUE),   # Standardabweichung Schnabellänge (ignoriert NA)
    
    # Quantile: Nützlich für Boxplots und Ausreißer-Erkennung
    q25_mass = quantile(body_mass_g, 0.25, na.rm = TRUE), # 25%-Quantil (unteres Viertel)
    q75_mass = quantile(body_mass_g, 0.75, na.rm = TRUE), # 75%-Quantil (oberes Viertel)
    
    # Minimum / Maximum
    min_bill_depth = min(bill_depth_mm, na.rm = TRUE),    # Kleinster Schnabel-Tiefenwert
    max_bill_depth = max(bill_depth_mm, na.rm = TRUE),    # Größter Schnabel-Tiefenwert
    
    # Anteil Weibchen (TRUE = weiblich, NA werden ignoriert)
    prop_female = sum(sex == "female", na.rm = TRUE) / sum(!is.na(sex)),
    
    # Weitere Statistik: Varianz des Körpergewichts
    var_mass = var(body_mass_g, na.rm = TRUE),           # Streuung des Gewichts
    
    .groups = "drop"      # Gruppierung nach dem summarise entfernen (damit Folgefunktionen normal arbeiten)
  ) %>%
  # Neue Variablen aus Ergebnissen berechnen
  mutate(
    mass_range = q75_mass - q25_mass,              # Interquartilsabstand = mittlere Streuung des Gewichts
    cv_bill_length = sd_bill_length / mean_body_mass,  # Variationskoeffizient: relative Streuung Schnabellänge
    sample_size_category = case_when(              # Gruppengröße klassifizieren
      count < 50 ~ "Small sample",
      count < 100 ~ "Medium sample", 
      TRUE ~ "Large sample"
    )
  )

# Ergebnisse ansehen: Sortieren nach mittlerem Gewicht, nur wichtige Spalten anzeigen
penguin_stats %>%
  arrange(desc(mean_body_mass)) %>%    # Größte Durchschnittsgewichte zuerst zeigen
  select(species, island, count, mean_body_mass, mass_range, prop_female)

# INTERPRETATION der Ergebnisse:
print("Interpretationshilfen:")
print("- Gentoo-Pinguine sind im Durchschnitt am schwersten")
print("- mass_range zeigt die Variabilität innerhalb jeder Art/Insel-Kombination")
print("- prop_female zeigt Geschlechterverteilung (sollte ~0.5 sein)")

```

WARUM das wichtig ist:

- Deskriptive Statistik ist Grundlage jeder Datenanalyse
- Gruppierte Analysen decken Unterschiede zwischen Subpopulationen auf
- Diese Kennzahlen sind Basis für statistische Tests
